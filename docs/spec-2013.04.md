# Introduction

After lots of experience with designing the `remoteStorage` API as part of the
_Unhosted_ project and using well established existing protocols we feel that
it is time to let go of the specifications that are for our purposes too 
bloated. We started out by leveraging existing protocols like WebDAV, Webfinger 
and OAuth, but as it turns out these protocols are way too complex to support 
minimalistic implementations. Those simple implementations are helpful for 
implementing the remoteStorage service on embedded devices and mobile 
platforms.

So, this spec will try to use as much as possible from existing standards like
WebDAV and OAuth, but will not strictly be bound by the specification if it 
serves simplicity.

# What Is Out?

Earlier versions of the spec also talked about discovery. How to figure out 
where a user's storage is located? Initial versions used *Webfinger* to perform
the discovery, but as it turns out it is nearly impossible to convince domain
owners, especially of larger organizations to implement Webfinger in a 
meaningful way, i.e.: add remoteStorage information and also provide CORS 
headers on the Webfinger endpoint. Another issue is the need to use user's 
email addresses which has some privacy concerns. Advertising user's email 
addresses in public URLs for sharing should be avoided. Also, the user 
experience while using Webfinger is a problem: the user needs to specify their
email address for every application. This approach to applications has been 
superseded by the way modern desktop operating systems, mobile devices and 
web browsers function: provide the user with an application launch screen. So, 
Webfinger is out and instead we will specify a _storage first_ approach that 
makes more sense to begin with.

Previous versions specified *WebDAV* as well. *WebDAV* is an existing HTTP 
based file storage and retrieval solution that would be perfectly suitable for 
this, but is very complex to implement and has lots of interoperability issues. 
WebDAV would be the way to go if it would mean that desktop and mobile 
operating systems would be able to use `remoteStorage` directly, but due to 
inflexible authentication mechanisms provided in the operating systems this is
unfeasible. There would need to be a separate client application anyway. So no
benefit there.

The other elephant in the room is OAuth. While the protocol itself is very 
flexible, everything is possible, it is also one of its weaknesses. So, in a 
sense OAuth is not out, we just specify very limited functionality of what part
of the OAuth specification will be implemented. It is more like a minimal 
profile instead of getting rid of it completely.

# What is In?

Basically still the same functionality as before, but now optimized for 
minimalistic implementations. It should be easy for anyone to write their
own remoteStorage server for the platform of their choice.

So, even though there is no longer discovery, there still is authorization, 
using a minimal OAuth profile and there is still the `remoteStorage` API to 
store and retrieve files.

# Storage First

In order to avoid the discovery problems introduced by implementing Webfinger
with CORS headers all around the Internet on all user domains a scenario 
for "storage first" is provided. Here, the user will browse to the service 
providing an "app launch" screen. This app launch screen provides a list of all 
available and installed applications and allows the user to launch them.

# remoteStorage API

The API did not change since last versions of the specification. This 
specification however will include (non normative) examples of each of the 
calls making it easy to see what is going on. The examples below are all 
without any authorization. See the next section for more information about 
authorization.

There are three HTTP verbs available in the `remoteStorage` API:

* `GET` - retrieve a file or directory listing
* `PUT` - store a file
* `DELETE` - delete a file
* `OPTIONS` - for advertizing CORS support, see section on Cross Origin Headers

A remoteStorage server has a *userRoot* directory, for instance:

    https://www.example.org/remoteStorage/api/john.doe/

Here, `john.doe` is the user identifier. This does not need to be identifiable
to the user and may very well be an opaque secure random generated user 
identifier, as long as it is persistent every time the user returns to the 
storage.

The user identifier is required in the URL because of public file sharing. The
file needs to be "namespaced" for a particular user.

All calls to either of the above `GET`, `PUT` and `DELETE` MUST be to 
the *userRoot* or directories or files under this directory, for instance:

    https://www.example.org/remoteStorage/api/john.doe/calendar/2012/10/14

## Retrieve a file or directory listing

It is possible to retrieve two things using the `GET` verb:

* files
* directory listings

To indicate whether or not a file or directory listing is requested the URL 
either contains a forward slash at the end, indicating a directory listing is 
request, or no forwarding slash, indicating a file is requested.

### Retrieving a file

#### Request

    GET /remoteStorage/api/john.doe/calendar/2012/10/14 HTTP/1.1

#### Response

    HTTP/1.1 200 OK
    Content-Type: application/json
    Content-Length: 106

    [{"start":"09:00","end":"10:00","activity":"Shopping"},{"start":"12:00","end":"13:00","activity":"Lunch"}]

If a file does not exist, a 404 error is returned: 

    HTTP/1.1 404 Not Found
    Content-Type: application/json
    Content-Length: 53

    {"error":"not_found","description":"file not found"}

The `Content-Type` given back to the client MUST be identical to the value that
was specified while uploading the file using `PUT`, described in the section 
below.

### Retrieving a directory listing

#### Request

    GET /remoteStorage/api/john.doe/calendar/2012/10/ HTTP/1.1

#### Response

    HTTP/1.1 200 OK
    Content-Type: application/json
    Content-Length: 49

    {"14":1344251958,"16":1344249635,"23":1344027615}

If a directory does not exist, an empty list is returned instead of a 404 error:

    HTTP/1.1 200 OK
    Content-Type: application/json
    Content-Length: 2

    {}

A sub directory in a file list is indicated by a forward slash at the end of 
the name, e.g.:

    {"foo/":134427616,"bar":1344293411}

Here `foo/` is a directory and `bar` is a file.

In addition, the timestamp of a directory MUST be the same as the timestamp 
of the file contained in that directory, all files, no matter how deep in the 
tree below that directory. It can be quite heavy to implement this on file 
directory listing, so it is probably beneficial to implement this on
`PUT` requests while storing a new file to _touch_ all directories in the path
to the file that is being stored. This feature is required because that makes
it very cheap for clients to maintain a copy of the contents of the storage 
server without traversing the entire store to locate updated objects.

## Store a file

A file is stored using the `PUT` verb. There is no `POST` because we want to 
specify the name of the resource the file will be stored under. Storing a 
file is straightforward.

If a directory a file belongs to does not exist already it will be silently 
created.

### Request

    PUT /remoteStorage/api/john.doe/calendar/2012/10/24 HTTP/1.1
    Content-Type: application/json
    Content-Length: 127

    [{"start":"10:00","end":"11:00","activity":"Book hostel"},{"start":"11:00","end":"11:30","activity":"Subscribe to conference"}]

### Response

    HTTP/1.1 200 OK

As mentioned in the section above about directory listings it may be better to 
implement the timestamp of directories here depending on the file storage 
backend.

In addition, the `Content-Type` of the file MUST be retained and given back to
the client on file retrieval. This is especially important for `public` files.

## Delete a file

Files can be deleted, directories cannot. Files can be deleted using the 
`DELETE` verb.

### Request

    DELETE /remoteStorage/api/john.doe/calendar/2012/10/24 HTTP/1.1

### Response

    HTTP/1.1 200 OK

In case a request for deletion specifies a directory, i.e. the URL ends with a 
forward slash, an error needs to be given back to the client:

    HTTP/1.1 400 Bad Request
    Content-Type: application/json
    Content-Length: 74

    {"error":"invalid_request","description":"a directory cannot be deleted"}

## Public Files

There is a "special" `public` directory in the *userRoot* indicating that all 
files under this directory are public. This means the `GET` call for a file and
ONLY a file, not a directory listing is allowed without authorization. All other
requests need authorization as if they were not public.

## Cross Origin Headers

The `OPTIONS` request should result in a response that tells web browsers that 
cross origin requests are allowed.

### Request 

    OPTIONS /remoteStorage/api/john.doe/calendar/2012/10/24 HTTP/1.1

### Response

    Access-Control-Allow-Origin: *
    Access-Control-Allow-Headers: Content-Type, Authorization, Origin
    Access-Control-Allow-Methods: GET, PUT, DELETE

## Error Handling

Some of the errors that can occur are already shown in the previous sections. 
However, those were all related to the client making a "mistake". In case an
error occurs on the server, i.e.: the disk is full and a file can no longer
be stored a separate error needs to be given back to the user. 

### Server Error

    HTTP/1.1 500 Internal Server Error
    Content-Type: application/json
    Content-Length: 60

    {"error":"internal_server_error","description":"disk full"}

These errors typically mean that the storage server has a bug or is not 
managed well, e.g.: disk full.

### Authorization Error

It is also possible the an application tries to access or write files or 
directories to which it does not have any permission. For example the user 
`john.doe` authorized an application to access his calendar data, but the 
application now tries to access data belonging to `jane.doe`, i.e. go outside
the *userRoot* directory. This should not be allowed and an error should be 
returned:

    HTTP/1.1 403 Forbidden
    Content-Type: application/json
    Content-Length: 69

    {"error":"access_denied","description":"files belong to other user"}

Other errors relating to the OAuth scope are determined by the HTTP Bearer 
specification. The recommendations there MUST be followed.

# Authorization API

For the authorization, i.e.: what application is allowed to do what a subset of
the OAuth specification is taken. The HTTP Bearer specification however is 
used in its entirety. The OAuth server needs to implement version 2 of the 
protocol, the following is a list of what is needed for the implementation:

* Support the "Implicit Grant" type from section 4.2;
* Bearer access tokens do not expire, i.e. they are valid until revoked;

Before an application can use the `remoteStorage` API it needs to obtain a 
`Bearer` token. This token is opaque, i.e.: a secure random generated string 
encoded to the base64 alphabet as specified in the HTTP Bearer token 
specification.

Furthermore, the access token needs to have a scope belonging to the directory
the application wants to access. 

## Scopes

The scopes from the OAuth specification are also used in the `remoteStorage` 
API. Every application that wants to use remoteStorage needs to have the 
correct scope for the directory it wants to access. The scope encodes both the
directory and whether _read_ or _write_ access is requested. A `GET` can be 
performed with _read_ permissions, while a `PUT` and `DELETE` require _write_ 
permissions. The scope is encoded like this:

    <directory>:r
    <directory>:rw

This permission is sufficient for all directories under this directory. For 
instance:

    PUT /remoteStorage/api/john.doe/calendar/2012/10/24 HTTP/1.1

requires `calendar:rw` permissions. The `calendar` part of the scope refers to
the first directory after the *userRoot*. This scope is also valid for the 
`public` directory, so the same scope is valid for the next request:

    PUT /remoteStorage/api/john.doe/public/calendar/2012/10/24 HTTP/1.1

The following request only requires `calendar:r` permissions:

    GET /remoteStorage/api/john.doe/calendar/2012/10/ HTTP/1.1

The remoteStorage server needs to verify whether the scope matches the 
directory the application wants to access. So when `calendar:rw` permissions 
are given, it is valid only for `/calendar/*` and `/public/calendar/*`.

There are also two special scope values:

    :r
    :rw

These scopes, without directory, indicate they are valid for *all* directories 
under *userRoot*. Care should be taken to not give this permission to 
applications that do not need it.

## Application Registration

All applications need to be registered in the OAuth server as clients. This can 
be done automatically be subscribing the server to a trusted "app store" 
that provides a list of verified applications. 

The format of this manifest this "app store" SHOULD provide is shown below. It 
is using the Chrome Web Store format, It contains a list of all applications 
available from the app store:

    [
        {
            "app": {
                "launch": {
                    "web_url": "https://todomvc.example.org/"
                }, 
                "urls": [
                    "https://todomvc.example.org/"
                ]
            }, 
            "description": "Manage your TODO list.", 
            "icons": {
                "128": "https://todomvc.example.org/icon_x128.png"
            }, 
            "key": "yiZH3dk49O4n", 
            "name": "TodoMVC", 
            "permissions": [
                "tasks:rw"
            ], 
            "version": "1"
        }, 
        ...
    ]

The important fields for the application registration from the manifest and
their mapping to OAuth terminology are:

<table>
<tr><th>Manifest</th><th>OAuth</th><tr>
<tr><td>key</td><td>client_id</td></tr>
<tr><td>permissions</td><td>scope</td></tr>
<tr><td>web_url</td><td>redirect_uri</td></tr>
</table>

This manifest data can be imported into the OAuth client registration database
and be used by the portal as a list of available applications.

The OAuth service needs to provide an API to the portal to retrieve a list of 
available applications and make it possible to register user consent for a 
specific application to get access to their files as an optimization for the 
user experience.

# Application Launch

The applications are launched from the portal by providing it with additional
parameters in the fragment part of the URL. There are two parameters 
specified:

* `rs_api_uri` - URL pointing to the *userRoot* at the storage server
* `rs_authz_uri` - URL pointing to the OAuth authorize endpoint

The `rs_api_uri` parameter is for example like specified before: 
`https://www.example.org/remoteStorage/api/john.doe/` 
while the OAuth authorize endpoint points to the OAuth server in `rs_authz_uri`, for example: 
`https://auth.example.org/oauth2/authorize`.

A full URL then looks like this:

    https://todomvc.example.org/#rs_api_uri=https://www.example.org/remoteStorage/api/john.doe/&rs_authz_uri=https://auth.example.org/oauth2/authorize

# Versioning

The application and the storage server need to negotiate a version of the 
protocol they wish to use.

How to do this? Using HTTP Accept, Expect headers somehow?!

    Accept: application/json;

    Expect: ????

# References

* The OAuth 2.0 Authorization Framework
* The OAuth 2.0 Authorization Framework: Bearer Token Usage

* https://developers.google.com/chrome/apps/docs/developers_guide#manifest
